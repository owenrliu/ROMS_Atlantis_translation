# Alberto Rovellini
# 9/27/2021
#################################
# This is step 2 of the ROMS workflow
#################################

# code to interpolate the outputs from the ROMS-to-Atlantis transformation code and bring them on a 12 h time step
# It also populates boxes with no ROMS points with values from closest neighbor

# 11/1/2021 Added default behavior to populate boxes and faces with no information because no rho points intercepted them. 

# README:
# Limitations to this approach as of 11/02/2021 - in no particular order
# 1. Unclear how well this scales up with large output files but probably very poorly. Do we need an extra step before this where we break down data by month?
# 2. This does not break down files into months and years, which is what Hem's code needs for now
# 3. If empty boxes (i.e. boxes with no ROMS points in them) are separated from a full box by more than one other empty box, the approach will not fill them
# 4. This will need to be looped or vectorized if we have more than one input file - and we will

library(tidyverse)
library(rbgm)
library(sf)

# read data - consider that you may have a number of data input files - how does HC decide which came first? Merge them all together?
file_statevars <- '../../outputs/short/state_vars_test.dat'
file_transport <- '../../outputs/short/transport_test.dat'

roms_state_vars <- read.csv(file_statevars,sep='\t',header = T)
roms_hydro <- read.csv(file_transport,sep='\t',header = T)

# read in BGM info
atlantis_bgm <- read_bgm('../../data/atlantis/GOA_WGS84_V4_final.bgm')
atlantis_box <- atlantis_bgm$boxes
atlantis_face <- atlantis_bgm$faces

#############################################################
# This section addresses issues generated by the way that data are generate din the R code, which was all to comply with HC
# Because we are not using HC, there is no need to have this format for the dat files (in fact there is no need for dat files at all).
#TODO: fix the following in the R code relative to how DAT files are generated - but then Hems' code stops working
# have consistent layer numbering between avg and hydro files, instead of having depths in one and layers in the other! 
# have time steps consistently as seconds (oceantime)
# ditch the long names and all the special characters, do abbrevs and units instead
# should probably not bother with renumbering the faces in the hydro file if then we need to map them back to their unique ID!

# for now fix by changing the input manually here. Keep in mind that if you want to change the R code and the generated DAT files you will also
# need to change the logic in Hem's R code to get temp and salt forcings.
roms_state_vars <- roms_state_vars %>% 
  arrange(Time.Step,Polygon.number,desc(Depth.Layer..m.)) %>%
  group_by(Time.Step,Polygon.number) %>%
  mutate(layer=0:5) %>%
  ungroup() %>%
  as.data.frame()

#REMOVE WHEN FIXING NaN in R CODE
roms_state_vars <- roms_state_vars %>% 
  mutate(across(c(Vertical.velocity..m3.s.,Average.Temperature..Celsius.,Average.Salinity..PartPer1000.),as.numeric))
#############################################################

#############################################################
# Add missing boxes for state variables (rho points)
# At each time step, for each layer of the box, take the neighboring box with largest area and attribute values to the corresponding layers.
# Work with depths instead of depth layers
# this will need to be done at each time step - potentially computationally expensive if a lot of boxes

# Identify empty boxes based on the BGM
all_boxes <- atlantis_box %>% select(.bx0) %>% distinct() %>% pull()
statevar_boxes <- roms_state_vars %>% select(Polygon.number) %>% distinct() %>% pull()
empty_boxes <- setdiff(all_boxes,statevar_boxes)

# construct the depth layers
atlantis_z <- c(-30,-100,-200,-500,-1000,-4000)

build_Atlantis_depths <- function(botz,lyrs){ # build them so that 0 is the deepest, like in the state variable file
  # bottom of each layer, starting from shallowest
  lyrbot<-lyrs
  # layers to use are all those that are shallower than the given botz
  lyr_vec <- lyrbot[lyrbot>botz]
  # the depth of the deepest layer is equal to botz
  lyr_vec <- sort(c(lyr_vec,botz))
  # in Atlantis, each box has the same number of depth layers, but some layers have zero thickness
  # so we have to pad with zeroes to make all boxes have the same number of layers
  nzeroes <- length(lyrs)-length(lyr_vec)
  lyr_vec <- c(lyr_vec,rep(0,nzeroes))
  -lyr_vec
}

# for each box, find the neighboring boxes based on the face dataset, which contains information on the neighbors
empty_boxes_areas <- rbind(atlantis_face %>% filter(left %in% empty_boxes) %>% select(left,right) %>% setNames(c('focal','neighbor')),
                             atlantis_face %>% filter(right %in% empty_boxes) %>% select(right,left) %>% setNames(c('focal','neighbor'))) %>%
  distinct() %>% 
  arrange(focal) %>%
  left_join(atlantis_box %>% select(.bx0,area), by = c('neighbor'='.bx0')) %>%
  group_by(focal) %>%
  filter(area==max(area)) %>% # use this to only use the largest neighbor
  ungroup() %>%
  left_join(atlantis_box %>% select(.bx0,area,botz), by = c('focal'='.bx0')) %>% # add botz and area of focal box - we will need the latter to rescale w
  setNames(c('focal','neighbor','area_neighbor','area_focal','botz')) %>% 
  mutate(Depth.Layer..m.=purrr::map(botz,~build_Atlantis_depths(.,lyrs=atlantis_z))) %>%
  unnest(cols = c(Depth.Layer..m.)) %>%
  group_by(focal,neighbor) %>%
  mutate(layer=0:5, # add numbered depth layer
         minz=lead(Depth.Layer..m.,default=0)) %>% # add top of each depth layer for pairing with neighboring box
  ungroup() 

# add time steps and make a template
time_steps <- roms_state_vars %>% select(Time.Step) %>% distinct() %>% pull()
empty_box_template <- data.frame('Time.Step'=rep(time_steps, each=nrow(empty_boxes_areas)),
                                 empty_boxes_areas %>% slice(rep(row_number(),length(time_steps))))

# need to add top depth of each layer to the state variables data frame
roms_state_vars <- roms_state_vars %>% 
  group_by(Time.Step,Polygon.number) %>%
  mutate(minz=lead(Depth.Layer..m.,default=0)) %>%
  ungroup()

# write function that writes the variables from the neighboring boxes - needs to be done for each time step
fill_variables <- function(ts,box,area_f,area_n,maxdepth,mindepth,statevars){
 
  if(maxdepth==mindepth){ # if the layer has dz=0, there are no stativ variables in it (they are the empty layers at the surface)
    vars<-rep(NA,3)
    }
  else{
    this_statevars <- statevars %>% filter(Time.Step==ts & Polygon.number==box & minz==mindepth & mindepth!=Depth.Layer..m.) # depth layer of 0 depth are empty layers
    
    this_w <- this_statevars %>% mutate(Vertical.velocity..m3.s.=Vertical.velocity..m3.s./area_n*area_f) %>% pull(Vertical.velocity..m3.s.)
    this_temp <- this_statevars %>% pull(Average.Temperature..Celsius.)
    this_salt <- this_statevars %>% pull(Average.Salinity..PartPer1000.)
    
    vars <- c(this_w,this_temp,this_salt)
    vars
  }
}

# Some boxes will still be empty after the first pass if they did not have any neighbors with data
roms_state_vars_new <- empty_box_template %>%
  mutate(vars=purrr::pmap(list(ts=Time.Step,box=neighbor,maxdepth=Depth.Layer..m.,mindepth=minz,area_f=area_focal,area_n=area_neighbor),
                          fill_variables,statevars=roms_state_vars))%>%
  unnest_wider(col = c(vars)) %>%
  group_by(Time.Step,focal) %>% # remove boxes that are still empty after the first pass, because they have no full neighbors
  mutate(na_prop=length(which(is.na(...1)))/length(...1)) %>% # set a counter of the NAs
  filter(na_prop<1) %>% # 1 indicates all layers have NAs, i.e. there were no boxes to get data from
  select(-na_prop) %>%
  ungroup() %>% # end of NA remover (basically a case-specific na.rm for only empty boxes, we want to keep the NAs for the empty layers)
  select(Time.Step,focal,Depth.Layer..m.,...1,...2,...3,layer,minz) %>%
  setNames(colnames(roms_state_vars))
# subset empty_box_template to have only empty box

empty_box_template_new <- empty_box_template %>%
  filter(focal %in% setdiff(unique(empty_box_template$focal),unique(roms_state_vars_new$Polygon.number)))
# rerun function on that and the new roms_state_vars

roms_state_vars_new_2 <- empty_box_template_new %>%
  mutate(vars=purrr::pmap(list(ts=Time.Step,box=neighbor,maxdepth=Depth.Layer..m.,mindepth=minz,area_f=area_focal,area_n=area_neighbor),
                          fill_variables,statevars=roms_state_vars_new)) %>% 
  unnest_wider(col = c(vars)) %>%
  select(Time.Step,focal,Depth.Layer..m.,...1,...2,...3,layer,minz) %>%
  setNames(colnames(roms_state_vars))

# this approach fails for more than two degrees of separation of a box from a box with data
#TODO: change this so that it uses the largest neighbor if a neighbor is available, or a neighbor of a neighbor however many degrees of separation that involves
# bind everything by row - this is the ROMS data with boxes with no rho points filled based on neighbors

roms_state_vars <- rbind(roms_state_vars,roms_state_vars_new,roms_state_vars_new_2) %>%
  arrange(Time.Step,Polygon.number) %>%
  data.frame()
#############################################################

#############################################################
# fill at 12 h time steps by linear interpolation
# sometimes the ROMS time series may have gaps. If we ignore them, time steps may end up being shifted
# Write a function that: 
# 1. Takes as arguments the ROMS-to-Atlantis outputs and whether they are state variables
# 2. Builds a sequence of time steps from t0 (the first of the series whenever that would be) and going forward every 12 h
# 3. fills the time series at each 12 h time step by box and depth layer (and face for the fluxes)

fill_time_steps_12h <- function(roms_data,statevars){
  ts <- unique((roms_data[,grep('Time',colnames(roms_data))]))
  t_0 <- as.POSIXct(ts[1],origin='1900-01-01',tz='UTC') # this has to be specific to your ROMS, so check your origin and tz
  t_end <- as.POSIXct(ts[length(ts)],origin='1900-01-01',tz='UTC')
  complete <- seq(from=t_0,to=t_end,by=60*60*12) # 12 hours is the target for HC, units from ts are in seconds
  
  # change time column to actual times
  roms_data[,grep('Time',colnames(roms_data))] <- as.POSIXct(roms_data[,grep('Time',colnames(roms_data))],
                                                             origin='1900-01-01',tz='UTC')
  
  boxes <- unique(roms_data$Polygon.number)
  df_all <- as.data.frame(matrix(ncol=ncol(roms_data)))[-1,] # prepare an empty data frame to fill
  
  if(isTRUE(statevars)){ # for state variables (salt, temp, w, etc.)
    for(Ibox in 1:length(boxes)){
      layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$layer)
      for(Ilyr in 1:length(layers)){
        this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & roms_data$layer==layers[Ilyr],]
        # maintaining names as they are in the data
        # escape NAs (clunky, revisit this)
        
        if(length(which(is.na(this_cell$Vertical.velocity..m3.s.)))/nrow(this_cell)==1){
          Vertical.velocity..m3.s. <- rep(NA,length(complete))
        } else {
          Vertical.velocity..m3.s. <- approx(this_cell$Time.Step,this_cell$Vertical.velocity..m3.s.,xout=complete,rule=2)$y
        }
        
        if(length(which(is.na(this_cell$Average.Temperature..Celsius.)))/nrow(this_cell)==1){
          Average.Temperature..Celsius. <- rep(NA,length(complete))
        } else {
          Average.Temperature..Celsius. <- approx(this_cell$Time.Step,this_cell$Average.Temperature..Celsius.,xout=complete,rule=2)$y
        }
        
        if(length(which(is.na(this_cell$Average.Salinity..PartPer1000.)))/nrow(this_cell)==1){
          Average.Salinity..PartPer1000. <- rep(NA,length(complete))
        } else {
          Average.Salinity..PartPer1000. <- approx(this_cell$Time.Step,this_cell$Average.Salinity..PartPer1000.,xout=complete,rule=2)$y
        }
                                                 
        # put together into a data frame
        df_long <- data.frame('Time.Step'=complete,
                              'Polygon.number'=boxes[Ibox],
                              'Depth.Layer..m.'=this_cell$Depth.Layer..m.[1],
                              Vertical.velocity..m3.s.,
                              Average.Temperature..Celsius.,
                              Average.Salinity..PartPer1000.,
                              layer=this_cell$layer[1])

        df_all <- rbind(df_all,df_long)
      }
    }
    df_all <- df_all %>% arrange(Time.Step,Polygon.number,Depth.Layer..m.) #%>%
      #mutate(Time.Step=(as.numeric(difftime(Time.Step,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs

  } else { # ...and for fluxes between boxes
    for(Ibox in 1:length(boxes)){
      faces <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Face.number)
      for(Iface in 1:length(faces)){
        layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Depth.Layer)
        for(Ilyr in 1:length(layers)){
          this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & 
                                   roms_data$Face.number==faces[Iface] &
                                   roms_data$Depth.Layer==layers[Ilyr],]
          # maintaining names as they are in the data
          Flux..m3.s. <- approx(this_cell$Time.Step..12.hr,this_cell$Flux..m3.s.,xout=complete,rule=2)$y
          # put together into a data frame
          df_long <- data.frame('Polygon.number'=boxes[Ibox],
                                'Face.number'=faces[Iface],
                                'Time.Step..12.hr'=complete,
                                'Depth.Layer'=layers[Ilyr],
                                Flux..m3.s.,
                                'FaceID'=this_cell$FaceID[1])
          df_all <- rbind(df_all,df_long)
        }
      }
    }
    df_all <- df_all %>% arrange(Time.Step..12.hr,Polygon.number,Face.number,Depth.Layer) #%>%
      #mutate(Time.Step..12.hr=(as.numeric(difftime(Time.Step..12.hr,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs

  }
  return(df_all)
}

# apply (it is slow with the transport files)

roms_state_vars_interp <- fill_time_steps_12h(roms_data = roms_state_vars,statevars = TRUE)
roms_hydro_interp <- fill_time_steps_12h(roms_data = roms_hydro,statevars = FALSE)

#############################################################
# some plotting
# b <- sample(unique(roms_state_vars$Polygon.number),1)
# l <- 0
# 
# plot(roms_state_vars %>% filter(Polygon.number==b,layer==l) %>% pull(Time.Step),
#      roms_state_vars %>% filter(Polygon.number==b,layer==l) %>% pull(Vertical.velocity..m3.s.))
# 
# plot(roms_state_vars_interp %>% filter(Polygon.number==b,layer==l) %>% pull(Time.Step),
#      roms_state_vars_interp %>% filter(Polygon.number==b,layer==l) %>% pull(Vertical.velocity..m3.s.))
#############################################################

# rename columns to replace '.' with ' ' (probably we can change the ROMS transformation code to skip a couple of these flips back and forth)
colnames(roms_state_vars_interp) <- c(colnames(read.csv(file_statevars,sep='\t',check.names = FALSE)),"layer")
colnames(roms_hydro_interp) <- colnames(read.csv(file_transport,sep='\t',check.names = FALSE))

# export
write.table(roms_state_vars_interp, '../../outputs/short/avg.dat', 
            quote=FALSE, row.names = FALSE, sep = '\t')

write.table(roms_hydro_interp, '../../outputs/short/flux.dat', 
            quote=FALSE, row.names = FALSE, sep = '\t')