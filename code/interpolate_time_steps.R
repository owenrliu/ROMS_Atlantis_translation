# Alberto Rovellini
# 9/27/2021
# code to interpolate the outputs from the ROMS-to-Atlantis transformation code and bring them on a 12 h time step
# It also changes the time step column from ocean time to numbered time steps
library(tidyverse)

# read data - consider that you may have a number of data input files - how does HC decide which came first? Merge them all together?

file1 <- '../../outputs/short/state_vars_test.dat'
file2 <- '../../outputs/short/transport_test.dat'

roms_state_vars <- read.csv(file1,sep='\t',header = T)
roms_hydro <- read.csv(file2,sep='\t',header = T)

# sometimes the ROMS time series may have gaps. If we ignore them, time steps may end up being shifted
# Write a function that: 
# 1. Takes as arguments the ROMS-to-Atlantis outputs and whether they are state variables
# 1. Builds a sequence of time steps from t0 (the first of the series whenever that would be) and going forward every 12 h
# 2. fills the time series at each 12 h time step by box and depth layer (and face for the fluxes)


# Fixing the data ---------------------------------------------------------

# This section addresses issues generated by the way that data are generate din the R code, which was all to comply with HC
# Because we are not using HC, there is no need to have this format for the dat files (in fact there is no need for dat files at all).
#TODO: fix the following in the R code relative to how DAT files are generated
# make sure all missing values are NAs, not NaNs
# have consistent layer numbering between avg and hydro files, instead of having depths in one and layers in the other!
# have time steps consistently as seconds (oceantime)
# ditch the long names and all the special characters, do abbrevs and units instead
# should probably not bother with renumbering the faces in the hydro file if then we need to map them back to their unique ID!

# for now fix by changing the input manually here. Keep in mind that if you want to change the R code and the generated DAT files you will also
# need to change the logic in Hem's R code to get temp and salt forcings.
roms_state_vars <- roms_state_vars %>% 
  arrange(Time.Step,Polygon.number,desc(Depth.Layer..m.)) %>%
  group_by(Time.Step,Polygon.number) %>%
  mutate(layer=0:5) %>%
  ungroup() %>%
  as.data.frame()

#NOTE: if we keep empty (i.e. non-existent) layers in the data, the interpolation fails on NAs

########REMOVE WHEN FIXING NaN in R CODE######################
roms_state_vars <- roms_state_vars %>% 
  mutate(across(c(Vertical.velocity..m3.s.,Average.Temperature..Celsius.,Average.Salinity..PartPer1000.),as.numeric))

# change NaN with NA...
roms_state_vars$Average.Temperature..Celsius.[is.nan(roms_state_vars$Average.Temperature..Celsius.)] <- NA
roms_state_vars$Average.Salinity..PartPer1000.[is.nan(roms_state_vars$Average.Salinity..PartPer1000.)] <- NA
#############################################################

fill_time_steps_12h <- function(roms_data,statevars){
  ts <- unique((roms_data[,grep('Time',colnames(roms_data))])) # for some odd reason now this REFUSES to work without pull()
  t_0 <- as.POSIXct(ts[1],origin='1900-01-01',tz='UTC') # this has to be specific to your ROMS, so check your origin and tz
  t_end <- as.POSIXct(ts[length(ts)],origin='1900-01-01',tz='UTC')
  complete <- seq(from=t_0,to=t_end,by=60*60*12) # 12 hours is the target for HC, units from ts are in seconds
  
  # change time column to actual times
  roms_data[,grep('Time',colnames(roms_data))] <- as.POSIXct(roms_data[,grep('Time',colnames(roms_data))],origin='1900-01-01',tz='UTC')
  
  boxes <- unique(roms_data$Polygon.number)
  df_all <- as.data.frame(matrix(ncol=ncol(roms_data)))[-1,] # prepare an empty data frame to fill
  
  if(isTRUE(statevars)){ # for state variables (salt, temp, w, etc.)
    for(Ibox in 1:length(boxes)){
      layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$layer)
      for(Ilyr in 1:length(layers)){
        this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & roms_data$layer==layers[Ilyr],]
        # maintaining names as they are in the data
        # escape NAs (clunky, revisit this)
        
        if(length(which(is.na(this_cell$Vertical.velocity..m3.s.)))/nrow(this_cell)==1){
          Vertical.velocity..m3.s. <- rep(NA,length(complete))
        } else {
          Vertical.velocity..m3.s. <- approx(this_cell$Time.Step,this_cell$Vertical.velocity..m3.s.,xout=complete,rule=2)$y
        }
        
        if(length(which(is.na(this_cell$Average.Temperature..Celsius.)))/nrow(this_cell)==1){
          Average.Temperature..Celsius. <- rep(NA,length(complete))
        } else {
          Average.Temperature..Celsius. <- approx(this_cell$Time.Step,this_cell$Average.Temperature..Celsius.,xout=complete,rule=2)$y
        }
        
        if(length(which(is.na(this_cell$Average.Salinity..PartPer1000.)))/nrow(this_cell)==1){
          Average.Salinity..PartPer1000. <- rep(NA,length(complete))
        } else {
          Average.Salinity..PartPer1000. <- approx(this_cell$Time.Step,this_cell$Average.Salinity..PartPer1000.,xout=complete,rule=2)$y
        }
                                                 
        # put together into a data frame
        df_long <- data.frame('Time.Step'=complete,
                              'Polygon.number'=boxes[Ibox],
                              'Depth.Layer..m.'=this_cell$Depth.Layer..m.[1],
                              Vertical.velocity..m3.s.,
                              Average.Temperature..Celsius.,
                              Average.Salinity..PartPer1000.,
                              layer=this_cell$layer[1])

        df_all <- rbind(df_all,df_long)
      }
    }
    df_all <- df_all %>% arrange(Time.Step,Polygon.number,Depth.Layer..m.) %>%
      mutate(Time.Step=(as.numeric(difftime(Time.Step,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs

  } else { # ...and for fluxes between boxes
    for(Ibox in 1:length(boxes)){
      faces <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Face.number)
      for(Iface in 1:length(faces)){
        layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Depth.Layer)
        for(Ilyr in 1:length(layers)){
          this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & 
                                   roms_data$Face.number==faces[Iface] &
                                   roms_data$Depth.Layer==layers[Ilyr],]
          # maintaining names as they are in the data
          Flux..m3.s. <- approx(this_cell$Time.Step..12.hr,this_cell$Flux..m3.s.,xout=complete,rule=2)$y
          # put together into a data frame
          df_long <- data.frame('Polygon.number'=boxes[Ibox],
                                'Face.number'=faces[Iface],
                                'Time.Step..12.hr'=complete,
                                'Depth.Layer'=layers[Ilyr],
                                Flux..m3.s.,
                                'FaceID'=this_cell$FaceID[1])
          df_all <- rbind(df_all,df_long)
        }
      }
    }
    df_all <- df_all %>% arrange(Time.Step..12.hr,Polygon.number,Face.number,Depth.Layer) %>%
      mutate(Time.Step..12.hr=(as.numeric(difftime(Time.Step..12.hr,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs

  }
  return(df_all)
}

# apply (it is slow with the transport files)

roms_state_vars_interp <- fill_time_steps_12h(roms_data = roms_state_vars,statevars = TRUE)
roms_hydro_interp <- fill_time_steps_12h(roms_data = roms_hydro,statevars = FALSE)

# some plotting
# b <- sample(unique(roms_state_vars$Polygon.number),1)
# l <- 0
# 
# plot(roms_state_vars %>% filter(Polygon.number==b,layer==l) %>% pull(Time.Step),
#      roms_state_vars %>% filter(Polygon.number==b,layer==l) %>% pull(Vertical.velocity..m3.s.))
# 
# plot(roms_state_vars_interp %>% filter(Polygon.number==b,layer==l) %>% pull(Time.Step),
#      roms_state_vars_interp %>% filter(Polygon.number==b,layer==l) %>% pull(Vertical.velocity..m3.s.))


# rename columns to replace '.' with ' ' (probably we can change the ROMS transformation code to skip a couple of these flips back and forth)

colnames(roms_state_vars_interp) <- c(colnames(read.csv(file1,sep='\t',check.names = FALSE)),"layer")
colnames(roms_hydro_interp) <- colnames(read.csv(file2,sep='\t',check.names = FALSE))

# export
write.table(roms_state_vars_interp, '../../outputs/short/avg.dat', 
            quote=FALSE, row.names = FALSE, sep = '\t')

write.table(roms_hydro_interp, '../../outputs/short/flux.dat', 
            quote=FALSE, row.names = FALSE, sep = '\t')
