# Alberto Rovellini
# 9/27/2021
#################################
# Step 2: break down into monthly files, fill empty boxes with values form their neighbor, and interpolate on 12-h time steps if necessary
#################################

# code to interpolate the outputs from the ROMS-to-Atlantis transformation code and bring them on a 12 h time step
# It also populates boxes with no ROMS points with values from closest neighbor

# 11/1/2021 Added default behavior to populate boxes and faces with no information because no rho points intercepted them. 

# README:
# Limitations to this approach as of 11/02/2021 - in no particular order
# 1. Unclear how well this scales up with large output files but probably very poorly. Do we need an extra step before this where we break down data by month?
# 2. This does not break down files into months and years, which is what Hem's code needs for now
# 3. If empty boxes (i.e. boxes with no ROMS points in them) are separated from a full box by more than one other empty box, the approach will not fill them
# 4. This will need to be looped or vectorized if we have more than one input file - and we will

library(tidyverse)
library(rbgm)
library(sf)
library(lubridate)

select <- dplyr::select

# read data - consider that you may have a number of data input files - how does HC decide which came first? Merge them all together?
file_statevars <- '../../outputs/2017/state_vars_test.dat'
file_transport <- '../../outputs/2017/transport_test.dat'

roms_state_vars <- read.csv(file_statevars,sep='\t',header = T)
roms_hydro <- read.csv(file_transport,sep='\t',header = T)

# read in BGM info
atlantis_bgm <- read_bgm('../../data/atlantis/GOA_WGS84_V4_final.bgm')
atlantis_box <- atlantis_bgm$boxes
atlantis_face <- atlantis_bgm$faces

#############################################################
# Pre-processing
# Change oceantime to real time
# TODO: do this step in the translation code
this_origin <- '1900-01-01'
this_tz <- 'UTC'
roms_state_vars <- roms_state_vars %>% mutate(Time.Step=as.POSIXct(Time.Step, origin=this_origin,tz=this_tz))
roms_hydro <- roms_hydro %>% mutate(Time.Step..12.hr=as.POSIXct(Time.Step..12.hr, origin=this_origin,tz=this_tz))
#############################################################

# Break down into monthly files
state_var_files <- split((roms_state_vars %>% mutate(Month=month(Time.Step),
                                         Year=year(Time.Step),
                                         Monthyear=paste(Month,Year,sep='_'))),
              f = ~Monthyear)
lapply(state_var_files, function(x) {
  x1 <- x %>% select(-Month,-Year,-Monthyear)
  write.table(x1, file=paste0('../../outputs/2017/monthly/pre-interp/',x$Monthyear[1],'_statevars.dat'), quote=FALSE, row.names = FALSE, sep='\t')})

hydro_files <- split((roms_hydro %>% mutate(Month=month(Time.Step..12.hr),
                                                     Year=year(Time.Step..12.hr),
                                                     Monthyear=paste(Month,Year,sep='_'))),
                         f = ~Monthyear)
lapply(hydro_files, function(x) {
  x1 <- x %>% select(-Month,-Year,-Monthyear)
  write.table(x1, file=paste0('../../outputs/2017/monthly/pre-interp/',x$Monthyear[1],'_hydro.dat'), quote=FALSE, row.names = FALSE, sep='\t')})

#############################################################
# Read in all monthly files at the same time - state variables and hydro
# maqke the entire code below a function - for now containing the other function...
# run that funtion on all files with lapply or purrr - use a flag for statevars or not

roms_files <- list.files('../../outputs/2017/monthly/pre-interp/',full.names = TRUE)

# write one function that fills the empty boxes and creates data at every 12h

roms_dat_file_cleaner <- function(roms_file){
  
  roms_data <- read.table(roms_file,sep='\t',header = T) # read this file
  roms_data[,which(grepl('Time',colnames(roms_data)))] <- as.POSIXct(roms_data[,which(grepl('Time',colnames(roms_data)))])
  
  if(grepl('statevars',roms_file)){ # if state variables, fill empty boxes
    
    #############################################################
    # This section addresses issues generated by the way that data are generate din the R code, which was all to comply with HC
    # Because we are not using HC, there is no need to have this format for the dat files (in fact there is no need for dat files at all).
    #TODO: fix the following in the R code relative to how DAT files are generated - but then Hems' code stops working
    # have consistent layer numbering between avg and hydro files, instead of having depths in one and layers in the other! 
    # have time steps consistently as seconds (oceantime)
    # ditch the long names and all the special characters, do abbrevs and units instead
    # should probably not bother with renumbering the faces in the hydro file if then we need to map them back to their unique ID!
    
    # for now fix by changing the input manually here. Keep in mind that if you want to change the R code and the generated DAT files you will also
    # need to change the logic in Hem's R code to get temp and salt forcings.
    roms_data <- roms_data %>% 
      arrange(Time.Step,Polygon.number,desc(Depth.Layer..m.)) %>%
      group_by(Time.Step,Polygon.number) %>%
      mutate(layer=0:5) %>%
      ungroup() %>%
      as.data.frame()
    
    #REMOVE WHEN FIXING NaN in R CODE
    roms_data <- roms_data %>% 
      mutate(across(c(Vertical.velocity..m3.s.,Average.Temperature..Celsius.,Average.Salinity..PartPer1000.),as.numeric))
    #############################################################
    
    #############################################################
    # Add missing boxes for state variables (rho points)
    # At each time step, for each layer of the box, take the neighboring box with largest area and attribute values to the corresponding layers.
    # Work with depths instead of depth layers
    # this will need to be done at each time step - potentially computationally expensive if a lot of boxes
    
    # Identify empty boxes based on the BGM
    all_boxes <- atlantis_box %>% select(.bx0) %>% distinct() %>% pull()
    statevar_boxes <- roms_data %>% select(Polygon.number) %>% distinct() %>% pull()
    empty_boxes <- setdiff(all_boxes,statevar_boxes)
    
    # construct the depth layers
    atlantis_z <- c(-30,-100,-200,-500,-1000,-4000)
    
    build_Atlantis_depths <- function(botz,lyrs){ # build them so that 0 is the deepest, like in the state variable file
      # bottom of each layer, starting from shallowest
      lyrbot<-lyrs
      # layers to use are all those that are shallower than the given botz
      lyr_vec <- lyrbot[lyrbot>botz]
      # the depth of the deepest layer is equal to botz
      lyr_vec <- sort(c(lyr_vec,botz))
      # in Atlantis, each box has the same number of depth layers, but some layers have zero thickness
      # so we have to pad with zeroes to make all boxes have the same number of layers
      nzeroes <- length(lyrs)-length(lyr_vec)
      lyr_vec <- c(lyr_vec,rep(0,nzeroes))
      -lyr_vec
    }
    
    # for each box, find the neighboring boxes based on the face dataset, which contains information on the neighbors
    empty_boxes_areas <- rbind(atlantis_face %>% filter(left %in% empty_boxes) %>% select(left,right) %>% setNames(c('focal','neighbor')),
                               atlantis_face %>% filter(right %in% empty_boxes) %>% select(right,left) %>% setNames(c('focal','neighbor'))) %>%
      distinct() %>% 
      arrange(focal) %>%
      left_join(atlantis_box %>% select(.bx0,area), by = c('neighbor'='.bx0')) %>%
      group_by(focal) %>%
      filter(area==max(area)) %>% # use this to only use the largest neighbor
      ungroup() %>%
      left_join(atlantis_box %>% select(.bx0,area,botz), by = c('focal'='.bx0')) %>% # add botz and area of focal box - we will need the latter to rescale w
      setNames(c('focal','neighbor','area_neighbor','area_focal','botz')) %>% 
      mutate(Depth.Layer..m.=purrr::map(botz,~build_Atlantis_depths(.,lyrs=atlantis_z))) %>%
      unnest(cols = c(Depth.Layer..m.)) %>%
      group_by(focal,neighbor) %>%
      mutate(layer=0:5, # add numbered depth layer
             minz=lead(Depth.Layer..m.,default=0)) %>% # add top of each depth layer for pairing with neighboring box
      ungroup() 
    
    # add time steps and make a template
    time_steps <- roms_data %>% select(Time.Step) %>% distinct() %>% pull()
    empty_box_template <- data.frame('Time.Step'=rep(time_steps, each=nrow(empty_boxes_areas)),
                                     empty_boxes_areas %>% slice(rep(row_number(),length(time_steps))))
    
    # need to add top depth of each layer to the state variables data frame
    roms_data <- roms_data %>% 
      group_by(Time.Step,Polygon.number) %>%
      mutate(minz=lead(Depth.Layer..m.,default=0)) %>%
      ungroup()
    
    # write function that writes the variables from the neighboring boxes - needs to be done for each time step
    fill_variables <- function(ts,box,area_f,area_n,maxdepth,mindepth,statevars){
      
      if(maxdepth==mindepth){ # if the layer has dz=0, there are no stativ variables in it (they are the empty layers at the surface)
        vars<-rep(NA,3)
      }
      else{
        this_statevars <- statevars %>% filter(Time.Step==ts & Polygon.number==box & minz==mindepth & mindepth!=Depth.Layer..m.) # depth layer of 0 depth are empty layers
        
        this_w <- this_statevars %>% mutate(Vertical.velocity..m3.s.=Vertical.velocity..m3.s./area_n*area_f) %>% pull(Vertical.velocity..m3.s.)
        this_temp <- this_statevars %>% pull(Average.Temperature..Celsius.)
        this_salt <- this_statevars %>% pull(Average.Salinity..PartPer1000.)
        
        vars <- c(this_w,this_temp,this_salt)
        vars
      }
    }
    
    # Some boxes will still be empty after the first pass if they did not have any neighbors with data
    roms_data_new <- empty_box_template %>%
      mutate(vars=purrr::pmap(list(ts=Time.Step,box=neighbor,maxdepth=Depth.Layer..m.,mindepth=minz,area_f=area_focal,area_n=area_neighbor),
                              fill_variables,statevars=roms_data))%>%
      unnest_wider(col = c(vars)) %>%
      group_by(Time.Step,focal) %>% # remove boxes that are still empty after the first pass, because they have no full neighbors
      mutate(na_prop=length(which(is.na(...1)))/length(...1)) %>% # set a counter of the NAs
      filter(na_prop<1) %>% # 1 indicates all layers have NAs, i.e. there were no boxes to get data from
      select(-na_prop) %>%
      ungroup() %>% # end of NA remover (basically a case-specific na.rm for only empty boxes, we want to keep the NAs for the empty layers)
      select(Time.Step,focal,Depth.Layer..m.,...1,...2,...3,layer,minz) %>%
      setNames(colnames(roms_data))
    # subset empty_box_template to have only empty box
    
    empty_box_template_new <- empty_box_template %>%
      filter(focal %in% setdiff(unique(empty_box_template$focal),unique(roms_data_new$Polygon.number)))
    # rerun function on that and the new roms_data
    
    roms_data_new_2 <- empty_box_template_new %>%
      mutate(vars=purrr::pmap(list(ts=Time.Step,box=neighbor,maxdepth=Depth.Layer..m.,mindepth=minz,area_f=area_focal,area_n=area_neighbor),
                              fill_variables,statevars=roms_data_new)) %>% 
      unnest_wider(col = c(vars)) %>%
      select(Time.Step,focal,Depth.Layer..m.,...1,...2,...3,layer,minz) %>%
      setNames(colnames(roms_data))
    
    # this approach fails for more than two degrees of separation of a box from a box with data
    #TODO: change this so that it uses the largest neighbor if a neighbor is available, or a neighbor of a neighbor however many degrees of separation that involves
    # bind everything by row - this is the ROMS data with boxes with no rho points filled based on neighbors
    
    roms_data <- rbind(roms_data,roms_data_new,roms_data_new_2) %>%
      arrange(Time.Step,Polygon.number) %>%
      data.frame()
    #############################################################
  } 

  #TODO: put this in a separate file
  #############################################################
  # fill at 12 h time steps by linear interpolation
  # sometimes the ROMS time series may have gaps. If we ignore them, time steps may end up being shifted
  # Write a function that: 
  # 1. Takes as arguments the ROMS-to-Atlantis outputs and whether they are state variables
  # 2. Builds a sequence of time steps from t0 (the first of the series whenever that would be) and going forward every 12 h
  # 3. fills the time series at each 12 h time step by box and depth layer (and face for the fluxes)
  
  fill_time_steps_12h <- function(roms_data,statevars){
    
    ts <- unique((roms_data[,grep('Time',colnames(roms_data))]))
    
    if(length(ts)>1){ # if there is one data point (e.g. when testing), no need to interpolate
      t_0 <- as.POSIXct(ts[1],origin='1900-01-01',tz='UTC') # this has to be specific to your ROMS, so check your origin and tz
      t_end <- as.POSIXct(ts[length(ts)],origin='1900-01-01',tz='UTC')
      complete <- seq(from=t_0,to=t_end,by=60*60*12) # 12 hours is the target for HC, units from ts are in seconds
      
      boxes <- unique(roms_data$Polygon.number)
      df_all <- as.data.frame(matrix(ncol=ncol(roms_data)))[-1,] # prepare an empty data frame to fill
      
      if(isTRUE(statevars)){ # for state variables (salt, temp, w, etc.)
        for(Ibox in 1:length(boxes)){
          layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$layer)
          for(Ilyr in 1:length(layers)){
            this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & roms_data$layer==layers[Ilyr],]
            # maintaining names as they are in the data
            # escape NAs (clunky, revisit this)
            
            if(length(which(is.na(this_cell$Vertical.velocity..m3.s.)))/nrow(this_cell)==1){
              Vertical.velocity..m3.s. <- rep(NA,length(complete))
            } else {
              Vertical.velocity..m3.s. <- approx(this_cell$Time.Step,this_cell$Vertical.velocity..m3.s.,xout=complete,rule=2)$y
            }
            
            if(length(which(is.na(this_cell$Average.Temperature..Celsius.)))/nrow(this_cell)==1){
              Average.Temperature..Celsius. <- rep(NA,length(complete))
            } else {
              Average.Temperature..Celsius. <- approx(this_cell$Time.Step,this_cell$Average.Temperature..Celsius.,xout=complete,rule=2)$y
            }
            
            if(length(which(is.na(this_cell$Average.Salinity..PartPer1000.)))/nrow(this_cell)==1){
              Average.Salinity..PartPer1000. <- rep(NA,length(complete))
            } else {
              Average.Salinity..PartPer1000. <- approx(this_cell$Time.Step,this_cell$Average.Salinity..PartPer1000.,xout=complete,rule=2)$y
            }
            
            # put together into a data frame
            df_long <- data.frame('Time.Step'=complete,
                                  'Polygon.number'=boxes[Ibox],
                                  'Depth.Layer..m.'=this_cell$Depth.Layer..m.[1],
                                  Vertical.velocity..m3.s.,
                                  Average.Temperature..Celsius.,
                                  Average.Salinity..PartPer1000.,
                                  layer=this_cell$layer[1])
            
            df_all <- rbind(df_all,df_long)
          }
        }
        df_all <- df_all %>% arrange(Time.Step,Polygon.number,Depth.Layer..m.) #%>%
        #mutate(Time.Step=(as.numeric(difftime(Time.Step,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs
        
      } else { # ...and for fluxes between boxes
        for(Ibox in 1:length(boxes)){
          faces <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Face.number)
          for(Iface in 1:length(faces)){
            layers <- unique(roms_data[roms_data$Polygon.number==boxes[Ibox],]$Depth.Layer)
            for(Ilyr in 1:length(layers)){
              this_cell <- roms_data[roms_data$Polygon.number==boxes[Ibox] & 
                                       roms_data$Face.number==faces[Iface] &
                                       roms_data$Depth.Layer==layers[Ilyr],]
              # maintaining names as they are in the data
              Flux..m3.s. <- approx(this_cell$Time.Step..12.hr,this_cell$Flux..m3.s.,xout=complete,rule=2)$y
              # put together into a data frame
              df_long <- data.frame('Polygon.number'=boxes[Ibox],
                                    'Face.number'=faces[Iface],
                                    'Time.Step..12.hr'=complete,
                                    'Depth.Layer'=layers[Ilyr],
                                    Flux..m3.s.,
                                    'FaceID'=this_cell$FaceID[1])
              df_all <- rbind(df_all,df_long)
            }
          }
        }
        df_all <- df_all %>% arrange(Time.Step..12.hr,Polygon.number,Face.number,Depth.Layer) #%>%
        #mutate(Time.Step..12.hr=(as.numeric(difftime(Time.Step..12.hr,t_0,units = 'hours'))/12)+1) # replace the true time with a time step counter - seems to be what HC needs
      }
      
    } else {
      if(isTRUE(statevars)){
        df_all <- roms_data %>% select(Time.Step,Polygon.number,Depth.Layer..m.,Vertical.velocity..m3.s.,Average.Temperature..Celsius.,Average.Salinity..PartPer1000.,layer) %>%
          arrange(Time.Step,Polygon.number,Depth.Layer..m.)
      }else{
        df_all <- roms_data %>% select(Polygon.number,Face.number,Time.Step..12.hr,Depth.Layer,Flux..m3.s.,FaceID) %>%
          arrange(Time.Step..12.hr,Polygon.number,Face.number,Depth.Layer)
      }
    }
    return(df_all)
  }
  
  # apply (it is slow with the transport files)
  
  if(grepl('statevars',roms_file)) {
    roms_data_interp <- fill_time_steps_12h(roms_data = roms_data,statevars = TRUE)
    #colnames(roms_data_interp) <- c(colnames(read.csv(file_statevars,sep='\t',check.names = FALSE)),"layer")
    #export
    monthyear <- paste(month(roms_data_interp$Time.Step[1]),year(roms_data_interp$Time.Step[1]),sep = '_')
    write.table(roms_data_interp, paste0('../../outputs/2017/monthly/post-interp/',monthyear,'_avg.dat'),
                quote=FALSE, row.names = FALSE, sep = '\t')
  } else {
    roms_data_interp <- fill_time_steps_12h(roms_data = roms_data,statevars = FALSE)
    #colnames(roms_data_interp) <- colnames(read.csv(file_transport,sep='\t',check.names = FALSE))
    #export
    monthyear <- paste(month(roms_data_interp$Time.Step..12.hr[1]),year(roms_data_interp$Time.Step..12.hr[1]),sep = '_')
    write.table(roms_data_interp, paste0('../../outputs/2017/monthly/post-interp/',monthyear,'_flux.dat'),
                quote=FALSE, row.names = FALSE, sep = '\t')
    
  }
  
}

lapply(roms_files,roms_dat_file_cleaner)
